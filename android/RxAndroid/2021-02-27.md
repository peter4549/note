# [RxJava](https://github.com/ReactiveX/RxJava/wiki)
RxJava is a Java VM implementation of [ReactiveX (Reactive Extensions)](https://reactivex.io/): a library for composing asynchronous and event-based programs by using observable sequences.

## RxJava is Lightweight
RxJava tries to be very lightweight. It is implemented as a single JAR that is focused on just the Observable abstraction and related higher-order functions.  
  
이벤트를 정의한 Observable 인스턴스에 대해 짧은 함수를 엮은(체인) 스트림같이 이벤트 결과 데이터를 가공하는 처리를 정의, 지연실행, 비동기 콜백을 할 수 있습니다.  
  
## 기본적인 사용법
```
val observable: Observable<String> = Observable.create {
    it.onNext("Rx")
    it.onNext("Java")
    it.onComplete()
}

val observer: Observer<String> = object: Observer<String> {
    override fun onSubscribe(d: Disposable?) {
        println("onSubscribe: d: $d")
    }

    override fun onNext(t: String?) {
        println("onNext: t: $t")
    }

    override fun onError(e: Throwable?) {
        println("onError: e: $e")
    }

    override fun onComplete() {
        println("onComplete")
    }
}

observable.subscribe(observer)
```
```
I/System.out: onSubscribe: d: CreateEmitter{null}
I/System.out: onNext: t: Rx
I/System.out: onNext: t: Java
I/System.out: onComplete
```
## 좀 더 간결하게 작성
`fromIterable`은 수신받은 배열이나 Iterator의 요소를 차례로 결과로 반환하는 Observable을 생성해준다.  
[Cannot resolve method Observable.from in rxjava 2](https://github.com/ReactiveX/RxJava/wiki/What's-different-in-2.0)
```
Observable.fromIterable(listOf("Rx", "Java")).subscribe(System.out::println)
```
```
I/System.out: Rx
I/System.out: Java
```
## Observable를 새로운 Observable으로 변환
map 메소드는 Observable을 별도의 Observable로 변환한다.
```
Observable.fromIterable(listOf("Rx", "Java"))
        .map { it.length }
        .subscribe(System.out::println)
```
```
I/System.out: 2
I/System.out: 4
```
## flatMap
그럼 배열의 요소가 Nest 한 경우는 어떨까요.  
flatMap을 사용해 Nest 한 요소를 병렬 결과로써 전달할 수 있습니다.  
여기서 flatMap의 Func1에서는 Observable 반환하지만, flatMap은 이 Observable을 분해해 늘여놓은 1개의 Observable을 생성해준다.
```
Observable.fromIterable(listOf(listOf("Rx", "Java"), listOf("Rx", "Kotlin")))
        .flatMap { Observable.fromIterable(it) }
        .map { it.length }
        .subscribe(System.out::println)  
```
```
I/System.out: 2
I/System.out: 4
I/System.out: 2
I/System.out: 6
```
## merge
복수 Observable을 합성하는 `merge`를 사용해 flatMap을 사용하지 않고 적는 것이 가능하다.
```
Observable.merge(Observable.fromIterable(listOf("Rx", "Java")), Observable.fromIterable(listOf("Rx", "Kotlin")))
        .map {
            it.length
        }.subscribe(System.out::println)
```
```
I/System.out: 2
I/System.out: 4
I/System.out: 2
I/System.out: 6
```
## filter
`filter`를 사용하면 결과를 취사선택 하는 것이 가능하다.
```
Observable.fromIterable(listOf(listOf("Rx", "Java"), listOf("Rx", "Kotlin")))
        .flatMap { Observable.fromIterable(it) }
        .filter { it != "Rx" }
        .map { it.length }
        .subscribe(System.out::println)
```
```
I/System.out: 4
I/System.out: 6
```
